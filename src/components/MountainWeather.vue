<template>
  <div class="page">
    <!-- 날짜 네비게이션 -->
    <div class="date-navigation">
      <Button
        icon="pi pi-chevron-left"
        @click="changeDate('prev')"
        :disabled="!canGoPrev"
        class="p-button-rounded"
      />
      <span>{{ selectedDate }} ({{ dayOfWeek }})</span>
      <Button
        icon="pi pi-chevron-right"
        @click="changeDate('next')"
        :disabled="!canGoNext"
        class="p-button-rounded"
      />
    </div>

    

    <main class="main-layout">
      <!-- WeatherTimeline -->
      <div class="weather-timeline">
        <WeatherTimeline
          :filteredForecastData="filteredForecastData || []"
          :chartOption="chartOption || {}"
          :selectedDate="selectedDate || ''"
          :canGoPrev="canGoPrev"
          :canGoNext="canGoNext"
          :changeDate="changeDate"
        />
      </div>


      <!-- Weather info section -->
      <div class="weather-info-grid">
        <div class="card">
            <div class="card-title">
              🌡️ 최저 / 최고 기온
            </div>
            <div class="card-pic card-pic--pressure"></div>
            <div class="card-info">
                <div class="card-centered">
                    <div class="info-main">
                        <div class="info-main-num">
                          {{ Math.round(selectedDateTemperatures.minTemp) }}  / {{ Math.round(selectedDateTemperatures.maxTemp) }} 

                        </div>
                        <div class="info-main-text">
                          °C
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-title">
              <div v-if="isSnowOnSelectedDate">❄️ 총 적설량</div>
              <div v-else>💧 총 강수량</div>
            </div>
            <div class="card-pic card-pic--humidity"></div>
            <div class="card-info">
                <div class="card-centered">
                    <div class="info-main">
                        <div class="info-main-num">
                          {{ selectedDateTotalRainOrSnow.toFixed(2) }}
                        </div>
                        <div class="info-main-text">
                           mm 
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-title">
              💨 최고 풍속 
            </div>
            <div class="card-pic card-pic--wind"></div>
            <div class="card-info">
                <div class="card-centered">
                    <div class="info-main">
                        <div class="info-main-num">
                          {{ Math.round(selectedDateMaxWindSpeed) }}
                        </div>
                        <div class="info-main-text">
                           m/s 
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
          <div class="card-title">
            🌪️ 최대 돌풍  
          </div>
          <div class="card-pic card-pic--gusts"></div>
          <div class="card-info">
              <div class="card-centered">
                  <div class="info-main">
                      <div class="info-main-num">
                        {{ Math.round(selectedDateMaxGust) }}
                      </div>
                      <div class="info-main-text">
                          m/s 
                      </div>
                  </div>
              </div>
          </div>
        </div>

    </div>
    </main>
  </div>
</template>


<script>
import WeatherTimeline from "@/components/WeatherTimeline.vue";
import Button from 'primevue/button';

export default {
  name: "MountainWeather",
  props: ["id"],
  components: {
    WeatherTimeline,
    Button,
  },
};
</script>

<script setup>
import { ref, onMounted, watch, reactive, computed } from 'vue';
import { API_KEY, BASE_URL, BASE_URL_FORECAST } from '../constants/index';

import * as echarts from 'echarts/core';
import { LineChart } from 'echarts/charts';
import {
TitleComponent,
TooltipComponent,
GridComponent
} from 'echarts/components';
import { CanvasRenderer } from 'echarts/renderers';
import VChart from 'vue-echarts';

echarts.use([
TitleComponent,
TooltipComponent,
GridComponent,
LineChart,
CanvasRenderer
]);


const props = defineProps(['id']);
let cityNameKor = '';
let latitude = 0;
let longtitude = 0;

switch (parseInt(props.id)) {
case 1:
  cityNameKor = '소백산';
  latitude = 36.9574906;
  longtitude = 128.4848843;
  break;
case 2:
  cityNameKor = '설악산';
  latitude = 38.1191376;
  longtitude = 128.4654324;
  break;
case 3:
  cityNameKor = '지리산';
  latitude = 35.3371088;
  longtitude = 127.7306952;
  break;
case 4:
  cityNameKor = '덕유산';
  latitude = 35.859908;
  longtitude = 127.746348;
  break;
case 5:
  cityNameKor = '가야산';
  latitude = 35.824953;
  longtitude = 128.119456;
  break;
case 6:
  cityNameKor = '북한산';
  latitude = 37.658931;
  longtitude = 126.977863;
  break;
case 8:
  cityNameKor = '월악산';
  latitude = 36.885850;
  longtitude = 127.105983;
  break;
case 9:
  cityNameKor = '계룡산';
  latitude = 36.351988;
  longtitude = 127.200391;
  break;
case 10:
  cityNameKor = '내장산';
  latitude = 35.478381;
  longtitude = 126.889014;
  break;
case 12:
  cityNameKor = '무등산';
  latitude = 35.121231;
  longtitude = 127.002920;
  break;
case 14:
  cityNameKor = '속리산';
  latitude = 36.543179;
  longtitude = 127.870750;
  break;
case 15:
  cityNameKor = '오대산';
  latitude = 37.794443;
  longtitude = 128.543581;
  break;
case 16:
  cityNameKor = '월출산';
  latitude = 34.766716;
  longtitude = 126.704170;
  break;
case 17:
  cityNameKor = '주왕산';
  latitude = 36.401330;
  longtitude = 129.203877;
  break;
case 18:
  cityNameKor = '치악산';
  latitude = 37.365124;
  longtitude = 128.055562;
  break;
case 19:
  cityNameKor = '태백산';
  latitude = 37.161537;
  longtitude = 128.917626;
  break;
case 21:
  cityNameKor = '팔공산';
  latitude = 36.016555;
  longtitude = 128.695349;
  break;
case 22:
  cityNameKor = '한라산';
  latitude = 33.3617;
  longtitude = 126.5297;
  break;
default:
  // 기본값 설정
  cityNameKor = '서울';
}

const city = ref(cityNameKor)

const weatherInfo = ref(null);
const weatherInfoForecast = reactive({});
const selectedDate = ref('');
const canGoPrev = computed(() => {
  const index = forecastDates.value.indexOf(selectedDate.value);
  return index > 0; // 0보다 크면 이전 버튼 활성화
});
const canGoNext = computed(() => {
  const index = forecastDates.value.indexOf(selectedDate.value);
  return index < forecastDates.value.length - 1; // 마지막 인덱스보다 작으면 다음 버튼 활성화
});
const forecastDates = ref([]);
const isError = computed(() => weatherInfo.value?.cod !== 200);
const isErrorForecast = computed(() => weatherInfoForecast.value?.cod !== 200);
const overallMinTemp = ref(Number.POSITIVE_INFINITY);
const overallMaxTemp = ref(Number.NEGATIVE_INFINITY);

const convertToKST = (utcDateTime) => {
const date = new Date(utcDateTime);
date.setHours(date.getHours() + 9); // UTC에서 KST로 변환하기 위해 9시간 더함

// YYYY-MM-DD HH:MM 형식으로 포맷팅
const year = date.getFullYear();
const month = String(date.getMonth() + 1).padStart(2, '0'); // 월은 0부터 시작하므로 1을 더함
const day = String(date.getDate()).padStart(2, '0');
const hours = String(date.getHours()).padStart(2, '0');
const minutes = String(date.getMinutes()).padStart(2, '0');
return `${year}-${month}-${day} ${hours}:${minutes}`;
};

const getWeather = async () => {
try {
  const response = await fetch(`${BASE_URL}?lat=${latitude}&lon=${longtitude}&units=metric&appid=${API_KEY}`);
  const response_forecast = await fetch(`${BASE_URL_FORECAST}?lat=${latitude}&lon=${longtitude}&units=metric&appid=${API_KEY}`);
  weatherInfo.value = await response.json();
  weatherInfoForecast.value = (await response_forecast.json()).list

  .map(item => {
    return { ...item, dt_txt: convertToKST(item.dt_txt) }; 
  });

  const allTemperatures = Object.values(weatherInfoForecast.value).flat().map(item => Math.round(item.main.temp));
  overallMinTemp.value = Math.min(...allTemperatures);
  overallMaxTemp.value = Math.max(...allTemperatures);

} catch (error) {
  console.log(error)
  isError.value = true;
  isErrorForecast.value = true;
}
};

const chartOption = ref({});

watch(selectedDate, (newDate) => {
if (newDate && weatherInfoForecast[newDate]) {
  const chartData = filteredForecastData.value.map(item => ({
    date: item.dt_txt.split(' ')[1].substring(0, 5),
    temp: Math.round(item.main.temp)
  }));

  chartOption.value = {
    xAxis: {
      type: 'category',
      data: chartData.map(data => data.date)
    },
    yAxis: {
      type: 'value',
      min: overallMinTemp,
      max: overallMaxTemp
    },
    series: [{
      data: chartData.map(data => data.temp),
      type: 'line',
      label: {
        show: true, 
        position: 'top', 
        formatter: '{c}°C' 
      }
    }]
  };
}
}, { immediate: true });

const groupForecastByDate = (forecastData) => {
const groupedData = {};
forecastData.forEach(item => {
  const date = item.dt_txt.split(' ')[0];
  if (!groupedData[date]) {
    groupedData[date] = [];
  }
  groupedData[date].push(item);
});
return groupedData;
};

onMounted(async () => {
  await getWeather();

  if (weatherInfoForecast .value) {
    const groupedForecast = groupForecastByDate(weatherInfoForecast.value);
    // 반응형 객체에 데이터 할당
    for (const date in groupedForecast) {
      weatherInfoForecast[date] = groupedForecast[date];
    }
    forecastDates.value = Object.keys(groupedForecast);
    selectedDate.value = forecastDates.value[0];
  }
});

const changeDate = (direction) => {
  const currentIndex = forecastDates.value.indexOf(selectedDate.value);
  if (direction === 'next' && currentIndex < forecastDates.value.length - 1) {
    selectedDate.value = forecastDates.value[currentIndex + 1];
  } else if (direction === 'prev' && currentIndex > 0) {
    selectedDate.value = forecastDates.value[currentIndex - 1];
  }
};

const dayOfWeek = computed(() => {
  if (!selectedDate.value) return '';
  const date = new Date(selectedDate.value);
  return date.toLocaleDateString('ko-KR', { weekday: 'short' }).slice(0, 1);
});

const filteredForecastData = computed(() => {
  if (!selectedDate.value || !weatherInfoForecast[selectedDate.value]) {
    return [];
}

return weatherInfoForecast[selectedDate.value]
  .filter(item => !excludedTimes.includes(item.dt_txt.split(' ')[1].substring(0, 5)));
});


const excludedTimes = ['00:00', '03:00'];

const selectedDateTemperatures = computed(() => {
  if (!selectedDate.value || !weatherInfoForecast[selectedDate.value]) {
    return { minTemp: null, maxTemp: null };
  }
  const temps = weatherInfoForecast[selectedDate.value]
    .filter(item => !excludedTimes.includes(item.dt_txt.split(' ')[1].substring(0, 5)))
    .map(item => item.main.temp);

  return {
    minTemp: Math.min(...temps),
    maxTemp: Math.max(...temps)
  };
});

const selectedDateTotalRainOrSnow = computed(() => {
  if (!selectedDate.value || !weatherInfoForecast[selectedDate.value]) {
    return 0;
}

return weatherInfoForecast[selectedDate.value]
  .filter(item => !excludedTimes.includes(item.dt_txt.split(' ')[1].substring(0, 5)))
  .reduce((total, item) => {
    if (item.weather[0].description.includes("snow")) {
      return total + (item.snow ? item.snow['3h'] : 0);
    }
    return total + (item.rain ? item.rain['3h'] : 0);
  }, 0);
});

const selectedDateMaxWindSpeed = computed(() => {
  if (!selectedDate.value || !weatherInfoForecast[selectedDate.value]) {
    return null;
}

return Math.max(...weatherInfoForecast[selectedDate.value]
  .filter(item => !excludedTimes.includes(item.dt_txt.split(' ')[1].substring(0, 5)))
  .map(item => item.wind.speed));
});

const selectedDateMaxGust = computed(() => {
  if (!selectedDate.value || !weatherInfoForecast[selectedDate.value]) {
    return null;
}
return Math.max(...weatherInfoForecast[selectedDate.value]
  .filter(item => !excludedTimes.includes(item.dt_txt.split(' ')[1].substring(0, 5)))
  .map(item => item.wind.gust || 0));
});

const timezone = computed(() => weatherInfo.value?.timezone)


// 강수량, 적설량 둘 다 있을 때 강수량으로 표기 (봄~가을)
/*
const isSnowOnSelectedDate = computed(() => {
return filteredForecastData.value.every(item => 
  !item.rain && item.weather[0].description.includes("snow")
);
});
*/

// 강수량, 적설량 둘 다 있을 때 적설량으로 표기 (겨울)
const isSnowOnSelectedDate = computed(() => {
return filteredForecastData.value.some(item => item.weather[0].description.includes("snow"));
});


</script>

<style lang="scss" scoped>
@use '../assets/styles/main.scss' as *;

.main-layout {
  display: flex;
  flex-direction: row; /* 가로 정렬을 위해 row 설정 */
  justify-content: center;
  align-items: center;
  width: 100%;
  max-width: 1200px;
  gap: 20px;
}

.date-navigation {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 20px;
}

.date-navigation span {
  font-size: 1.3rem; 
  margin: 0 1rem; 
}

.date-navigation .p-button {
  background-color:  #2196F3; 
  border: none;
  color: white;
  border-radius: 4px; 
  padding: 0.5rem 1rem; 
  margin: 10px;
}

.date-navigation .p-button:hover {
  background-color:  #1976D2; 
  border: none;
}

.date-navigation .p-button:disabled {
  background-color: transparent;
  color: transparent; 
  cursor: default;
}

.weather-timeline {
  flex: 1;
  margin-bottom: 50px;
}

.weather-info-grid {
  flex: 1;
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* 2x2 배치 설정 */
  gap: 0px;
}

.weather-detail {
  display: flex;
  flex-direction: column; /* 텍스트를 세로로 정렬 */
  align-items: center; /* 수직 중앙 정렬 */
  justify-content: center; /* 수평 중앙 정렬 */
  text-align: center;
}

.highlights {
    padding: 28px 16px 16px;
    background: url('/src/assets/img/gradient-4.jpg') no-repeat 0% 0%;
    background-size: cover;
    border-radius: 25px;

    &-wrapper {
        display: flex;
        justify-content: space-between;

        @media (max-width: 575px) {
            flex-direction: column;
        }
    }
}

.title {
    padding-bottom: 16px;
}

.highlight {
    width: 32%;

    @media (max-width: 575px) {
        width: 100%;
        margin-bottom: 16px;
    }
}

.card {
    width: 90%;
    height: 50%;
    margin: auto;
    min-height: 230px;
    padding: 16px;
    background: url('/src/assets/img/gradient-2.jpg') no-repeat 50% 50%;
    background-size: cover;
    border-radius: 8px;

    @media (max-width: 1199px) {
        padding: 12px;
    }

    &-centered {
        display: flex;
        justify-content: center;
        margin-top: 40px;
    }

    &-justify {
        display: flex;
        justify-content: space-between;
        margin-top: 40px;
    }


    &-title {
        padding-bottom: 12px;
        font-size: 16px;
        color: rgba(#fff, 0.75);
        @media (max-width: 1199px) {
            font-size: 12px;
        }
    }

    &-pic {
        width: 100%;
        height: 90px;
        margin-bottom: 5x;
        background-repeat: no-repeat;
        background-position: 50% 50%;
        background-size: contain;

        &--wind {
        background-image: url('/src/assets/img/equalizer (2).png');
    }

    &--pressure {
        background-image: url('/src/assets/img/barometer.png');
    }

    &--sun {
        background-image: url('/src/assets/img/sun-moving.png');
    }

    &--humidity {
        background-image: url('/src/assets/img/humidity.png');
    }

    &--gusts {
        background-image: url('/src/assets/img/gusts.svg');
    }

  }
}


.info-main {
    display: flex;
    align-items: flex-end;

    &:last-child {
        text-align: right;
    }

    &-num {
        font-size: 25px;
        color: rgba(#fff, 0.75);
        @media (max-width: 1199px) {
            font-size: 18px;
        }
    }

    &-text {
        padding-left: 2px;
        padding-bottom: 3px;
        font-size: 13px;
        color: rgba(#fff, 0.75);
        margin-left: 5px;

        @media (max-width: 1199px) {
            padding-bottom: 1.5px;
            font-size: 12px;
        }
    }
}

</style>